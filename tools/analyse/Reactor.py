import clang.cindex

import re
import itertools

# A class for generating and holding information about on statements
class On:
    briefRegex = re.compile(r"//.*@brief (.*)")

    def __init__(self, node):
        self.node = node
        self.dsl = self._findDSL()
        self.callback = self._findLambda()

    def __repr__(self):
        return "on<{}>(){{{}}}".format(self.dsl, self.callback)

    # Find the brief comment one line above
    def getBrief(self):
        comment = ""
        f = open(self.node.location.file.name, "r")
        for line in itertools.islice(f, self.node.location.line - 2, self.node.location.line - 1):
            regexed = re.findall(On.briefRegex, line)
            if regexed:
                comment = regexed[0]
        f.close()
        return comment

    # Look at the AST for the type that corresponds to the DSL
    def _findDSL(self):
        DSL = ""
        try:
            for dslChild in next(
                next(next(next(self.node.get_children()).get_children()).get_children()).get_children()
            ).get_children():
                # Build up the full typename
                if dslChild.kind == clang.cindex.CursorKind.TEMPLATE_REF:
                    DSL += "{}::".format(dslChild.spelling)
                elif dslChild.kind == clang.cindex.CursorKind.NAMESPACE_REF:
                    DSL += "{}::".format(dslChild.spelling)
                elif dslChild.kind == clang.cindex.CursorKind.TYPE_REF:
                    DSL += dslChild.type.spelling
        except StopIteration:
            pass
        return DSL

    # Find the definition of the callback
    def _findLambda(self):
        for child in self.node.get_children():
            try:
                if child.kind == clang.cindex.CursorKind.UNEXPOSED_EXPR:
                    callback = next(child.get_children())
                    if callback.kind != clang.cindex.CursorKind.LAMBDA_EXPR:
                        raise AssertionError("Was not a lambda, did not know was possible")
                    else:
                        return Method(callback)
                elif child.kind == clang.cindex.CursorKind.DECL_REF_EXPR:
                    return Method(child.referenced)
            except StopIteration:
                pass
            except AssertionError as e:
                print(e)
        return None


# A class for finding and storing data about emit statements
class Emit:
    existingUniqueRegex = re.compile(r"std::unique_ptr<(.*), std::default_delete<.*> >")
    makeUniqueRegex = re.compile(r"typename _MakeUniq<(.*)>::__single_object")
    nusightDataRegex = re.compile(
        r"std::unique_ptr<(.*)>"
    )  # generated by emit(graph("localisation ball pos", filter.get()[0], filter.get()[1]));
    briefRegex = re.compile(r"//.*@brief (.*)")

    def __init__(self, node):
        self.node = node
        self.scope = self._findScope()
        self.type = self._findType()

    def __repr__(self):
        return "emit<{}>({})".format(self.scope, self.type)

    def __eq__(self, value):
        return self.node == value.node

    # Gets the brief comment one line above
    def getBrief(self):
        comment = ""
        f = open(self.node.location.file.name, "r")
        for line in itertools.islice(f, self.node.location.line - 2, self.node.location.line - 1):
            regexed = re.findall(Emit.briefRegex, line)
            if regexed:
                comment = regexed[0]
        f.close()
        return comment

    # Looks for the templated type, which is the scope
    def _findScope(self):
        try:
            memberRefExpr = next(self.node.get_children())
            if memberRefExpr.kind != clang.cindex.CursorKind.MEMBER_REF_EXPR:
                raise AssertionError("First node in subtree of emit was not MEMBER_REF_EXPR, did not no was possible.")
            for part in memberRefExpr.get_children():
                if part.kind == clang.cindex.CursorKind.TEMPLATE_REF:
                    return part.spelling
        except StopIteration:
            pass
        except AssertionError as e:
            print(e)
        return "Local"

    # Find the type that is in the unique pointer that is passed to the emit
    def _findType(self):
        try:
            children = self.node.get_children()
            next(children)
            expr = next(children)
            if (
                expr.kind == clang.cindex.CursorKind.UNEXPOSED_EXPR
            ):  # The parameter is constructed in the emit statement
                regexed = re.findall(Emit.makeUniqueRegex, expr.type.spelling)
                if regexed:
                    return regexed[0]
                else:
                    return re.findall(Emit.nusightDataRegex, expr.type.spelling)[0]
            elif (
                expr.kind == clang.cindex.CursorKind.DECL_REF_EXPR
            ):  # The parameter is constructed outside the emit statement
                return re.findall(Emit.existingUniqueRegex, expr.type.spelling)[0]
            elif expr.kind == clang.cindex.CursorKind.MEMBER_REF_EXPR:  # the parameter is a member of a class
                return expr.type.spelling
        except StopIteration:
            pass
        return ""


# A class for finding on and emit statements within a method
class Method:
    def __init__(self, node):
        self.node = node
        self.calls = [node]
        self.onEmit = []
        self.emit = []
        self.on = self._findOnNodes()
        self._addEmitNodes()

    def __repr__(self):
        representation = self.node.spelling + "("
        for on in self.on:
            representation += " " + str(on)
        for emit in self.emit:
            representation += " " + str(emit)
        representation += ")"
        return representation

    def __eq__(self, value):
        return self.node == value.node

    def getName(self):
        return self.node.spelling

    def getOns(self):
        return self.on

    def getEmits(self):
        return self.emit

    def getBrief(self):
        return self.node.brief_comment

    # Walks the tree and finds on calls
    def _findOnNodes(self):
        ons = []
        for child in self.node.walk_preorder():
            if (
                child.kind == clang.cindex.CursorKind.CALL_EXPR
                and child.type.spelling == "NUClear::threading::ReactionHandle"
                and child.spelling == "then"
            ):
                on = On(child)
                # We will hit these nodes again when we search for emit statements, so we add them now so we don't duplicate
                for emit in on.callback.emit:
                    if emit not in (self.emit + self.onEmit):
                        self.onEmit.append(emit)
                ons.append(on)
        return ons

    # Walks the tree of this method looking for emit calls, and follows definitions of functions
    def _addEmitNodes(self):
        for child in self.node.walk_preorder():
            if child.kind == clang.cindex.CursorKind.CALL_EXPR and child.spelling == "emit":
                emit = Emit(child)
                if emit not in (self.emit + self.onEmit):
                    self.emit.append(emit)
            elif (
                child.kind == clang.cindex.CursorKind.CALL_EXPR
                and child.get_definition()
                and child.get_definition() not in self.calls
            ):
                self.calls.append(child.get_definition())
                self._addEmitFunction(child.get_definition())

    # Walks a tree of a function looking for emit calls, and follows definitions of functions
    def _addEmitFunction(self, node):
        for child in node.walk_preorder():
            if child.kind == clang.cindex.CursorKind.CALL_EXPR and child.spelling == "emit":
                emit = Emit(child)
                if emit not in (self.emit + self.onEmit):
                    self.emit.append(emit)
            elif (
                child.kind == clang.cindex.CursorKind.CALL_EXPR
                and child.get_definition()
                and child.get_definition() not in self.calls
            ):
                self.calls.append(child.get_definition())
                self._addEmitFunction(child.get_definition())


# A class for holding information about reactors
class Reactor:
    def __init__(self, node, methods):
        self.node = node
        self.methods = [Method(method) for method in methods]
        self.notDuplicateMethods = Reactor._removeDuplicateMethods(self.methods)

    def __repr__(self):
        reperesentation = self.node.type.spelling
        for method in self.methods:
            reperesentation += " {}".format(method)
        return reperesentation

    def getType(self):
        return self.node.type.spelling

    def getMethods(self):
        return self.methods

    def getMethodsNoDuplicate(self):
        return self.notDuplicateMethods

    def getBrief(self):
        return self.node.brief_comment

    # Tries to remove forward declared methods
    @staticmethod
    def _removeDuplicateMethods(methods):
        out = {}
        for method in methods:
            out[method.getName()] = method
        return out
