% Initialisation
\documentclass[english,12pt]{scrartcl}
\usepackage[]{babel}
% Input is utf8
\usepackage[utf8]{inputenc}
% Enables headers and footers
\usepackage[]{scrpage2}
% Lets us colour table cells
\usepackage[table]{xcolor}
% Allows todo list and todos
\usepackage[]{todonotes}
% Makes links in contents hyperlinked
\usepackage{hyperref}
% Make references appear in our table of contents
\usepackage[nottoc,numbib]{tocbibind}
% Allows us to put landscape sections of the document
\usepackage{pdflscape} % \usepackage{lscape} %Use escape for printing (doesn't rotate the pdf page)
% Provides a glossary
\usepackage[toc]{glossaries}
% Used for source code syntax highlighting
\usepackage{minted}

% Minted configuration
\usemintedstyle{vs}
\newminted{cpp}{tabsize=0,linenos,bgcolor=white!95!black}

% Gives us pretty diagrams
\usepackage{tikz}
\usetikzlibrary{calc,fit,positioning,chains,decorations.pathreplacing,shapes,backgrounds}

% Document Title and Author
\title{NUClear Design Document}
\author{2013 Final Year Project}

% Header and Footer
\pagestyle{scrheadings}
\ihead{\today}
\chead{}
\ohead{NUClear Design Document}
\ifoot{}
\cfoot{}
\ofoot{\pagemark}

% Requirements custom commands
\newcommand{\requirement}[1]{\textit{#1}}

% Skip line rather then indent paragraphs
\setlength{\parindent}{0.0in}
\setlength{\parskip}{0.1in}

% Start of document
\begin{document}
	\maketitle
	\vfill
	{\large
		\begin{description}
			\item [Status:] Draft 1
			\item [Version:] 0.5
		\end{description}}

	\clearpage
	\tableofcontents

	\section{Document Notes}
		\begin{tabular}{ p{0.1\textwidth} | p{0.6\textwidth} | p{0.3\textwidth} }
			\textbf{Version} & \textbf{Changes} & \textbf{Author} \\
			\hline

			0.1 &
			Initial Template &
			Jake Woods \\
			\hline

			0.2 &
			Fleshed Out Intro and Features &
			Jake Woods \\
			\hline
			
			0.3 &
			Added a much better intro &
			Jake Woods \\
			\hline
			
			0.4 &
			Improved some of NUClear and the Intro &
			Jake Woods \\
			\hline
			
			0.5 &
			Filled out all of the NUClear Design Features &
			Jake Woods \\
			\hline
			
			0.6 &
			Editing &
			Trent Houliston \\
			\hline
		\end{tabular}
		
	\clearpage
		
	\section{Summary}
		\subsection{Project Background}
			The NUbots are a team of Software Engineers and Computer Scientists who build software for robots in order to compete in RoboCup. 
			RoboCup is an international competition that pits two fearsome robots against each other in an intense soccer competition with the goal of challenging humans by the year 2050.
			
			The robot software system has been developed at the University of Newcastle by the NUbots since 2002 and has changed robots three times between 2002-2013 initially starting with the four-legged \textbf{Sony AIBO} robots followed by the two legged \textbf{Aldebaran Nao} and as of 2011 they are now using the \textbf{Robotis DARwIn-OP}.
			The NUbots have also been successful at taking home the coveted RoboCup trophy twice in their career.
			
			The existing robot software was developed by separating different processing systems (Vision, Localisation, Kinematics, etc...) into their own code modules that communicate using ad-hoc mechanisms on a per-module basis. 
			Unfortunately constant developer churn and a long-lived code base have resulted in a system that contains very impressive algorithms that are hindered by a myriad of complicated and confusing communication methods.
			
			Our team was asked to develop a solution to this communication problem by restructuring the architecture around the individual systems to allow them to communicate in a \textbf{Simple}, \textbf{Efficient} and \textbf{Unified} way. 
			
			We were also asked to assist with some of the fundamental problems with the existing architecture that have arisen from changing platforms and hardware over the years. 
			Our ultimate goal is to provide a system that allows the NUbots to focus on the amazing algorithms and research without spending a disproportionate amount of time writing code to move data from system to system.
				
		\subsection{Recommend Solution}
			After careful analysis of the existing system we determined that it is prohibitively expensive to incrementally refactor the existing code base.
			However we have also determined that the algorithmic parts of the system can be separated from the architecture without a massive investment of labour. 
			
			Based on these observations we decided to build a new architecture from the ground up while migrating the existing algorithms into the new system as it is built.
			It was important to ensure that we only made changes to algorithmic code when necessary to decouple it from the old architecture while still leaving the algorithm intact.
			
			\subsubsection{Technologies}
				A key requirement set out by the NUbots team was to make it possible to easily replace modules that provide information with completely different modules provided that they produce the same information. 
				For example it should be possible to replace the system that reads camera frames from the hardware with one that reads frames from a file without changing the rest of the system.
				
				To facilitate this we looked at a number of different communication strategies to identify architectures that promoted \emph{loose coupling} which is a measure of how dependent components are on each other. 
				Architectures that are \emph{loosely coupled} have been shown to support easy drop-in replacement of modules provided they require/provide the same information.
				 
				Currently the consensus in the robotics world is to utilise message passing systems whereby modules communicate by sending and receiving packets of data known as \emph{messages} without knowing where they are sending/receiving message to/from.
				
				During our research it was clear that the majority of mature robotic systems were built with a message-driven architecture in mind. 
				Currently \textbf{Robot Operating System (RobotOS)} is the de-facto standard platform for robotics research.
				RobotOS uses a message passing system and was considered very heavily as a replacement for the existing architecture.
				
				Unfortunately RobotOS has a very high performance penalty to support message passing which was completely unacceptable for resource-starved platforms such as the Darwin. 
				Other existing robot systems such as \textbf{Dynamic Data eXchange (DDX)} and \textbf{Pack Service Robotic Architecture} also suffer from the same issues. It seemed that all contemporary robotic systems have decided to trade performance for message passing and cross-language compatibility.
				
				Our team decided to leverage our C++ skills to build an alternative system named \textbf{NUClear} that provides message passing capabilities (and more) that are orders of magnitudes faster then the competing systems. 
				Once we had a proof-of-concept it was decided to use the NUClear architecture as the basis for the new NUbots architecture. NUClear is covered extensively in the Architecture Overview.
				
				\todo[inline] {Link the words Architecture Overview to the actual section}
				
		\subsection{Use Cases}
			Josiah is a fictional software engineer tasked with implementing a new vision algorithm on the robot to assist with recognising faces (to later target with toy missiles).
			He knows that the robot is already capable of capturing images with its camera.
			Luckily the robot system implements communication using NUClear. 
			He simply writes a new vision module using the NUClear API to request that image frames are sent 
			
			requesting the image information and NUClear ensures the image frames are sent to the appropriate modules.
		
	\section{NUClear Design}
		NUClear is the C++ library that we designed to enable developers to write modular systems that communicate using messages. 
		Modules are kept ignorant of each other and only know about the messages they send/receive. 
		This allows us to transparently drop in different producers/consumers without modifying the entire system.
		
		NUClear was designed to replace the most common method of communication in the existing architecture known as the Blackboard.
		Blackboards are a shared global memory store that all modules use to communicate by writing data to the blackboard and assuming it is read by the next module.
		Our design makes it easy to transition from similar globally accessible data to a message based event-driven architecture.
		NUClear is also capable of replacing other methods of communication currently in use in the existing system such as direct function calls.
		
		Our goal was to make a system that allows programmers to easily send/receive information between modules using mechanisms that are \textbf{Fast}, \textbf{Reliable} and \textbf{Intuitive}.

		\subsection{Features}
			\subsubsection{Simple API}
				It is critical that NUClear have a simple and intuitive interface that didn't require weeks of study to achieve productivity with.
				As such NUClear is designed to be usable by second year software students who have a basic understanding of C++. 
				With that in mind we ensured that there was a single well-defined function for the two key features of the architecture: sending and receiving messages. Sending is accomplished using the \textbf{Emit} function while receiving is accomplished using the \textbf{On} function.
				
				NUClear is designed around these two functions. \textbf{On} provides mechanisms to indicate that you are interested in a particular piece of information.
				\textbf{Emit} correspondingly allows you to provide information to the system.
				
				The major benefit of having such a small API is understandability. 
				Instead of having to memorise tens or hundreds of functions you just need to remember two key functions and you have the full power of NUClear at your fingertips.
				This makes it easy for new programmers to learn and understand.
			
			\subsubsection{Simple utilization of system resources}
				Another requirement derived from resource-constrained environments is the need to easily utilise the full power of the platform you run on.
				This is primarily achieve by introducing \textbf{Transparent Multi-threading} which automatically uses every physical core available on the system
				without the developer needing to fiddle with threading primitives.
				
				When a message is sent in the system the central coordination object known as the \textbf{PowerPlant} takes ownership of it. 
				From this point forward no modules can modify the message and only have read-only access to it.
				The PowerPlant then executes callbacks, known as reactions, that are subscribed to this message.
				Each reaction gets a immutable reference to the original message and can perform any read operations on it.
				
				Immutability is the key that allows us to transparently multi-thread the system.
				We know that multiple reactions will want to read the data and if we can guarantee that they don't modify it then we can
				run the reactions in parallel without worrying about race conditions.
				By forcing immutability we can move all threading logic directly into NUClear allowing developers to concentrate on their modules
				instead of threading problems.
				
				In most cases multi-threading will be completely transparent. 
				However it is still important that the developers understand that they are working in a multi-threaded environment.
				If a single module shares data between two reactions and those reactions could run in parallel then the shared data will
				need to be secured with a thread-safe mechanism such as a mutex.
				NUClear also provides functionality to let the user specify that certain reactions should not be run in parallel which can be used to solve threading concerns.
			
			\subsubsection{Low Performance Penalty}
				In order to meet our clients requirements it is essential that message routing is performed as quickly as possible. 
			
				Because of this we have opted not to use technologies that incur large performance penalties such as text-based message serialisation (XML, JSON).
				Instead we have chosen a direct binary representation for messages passed within a single process. 
				
				We also need to minimise the amount of time it takes to send a message. 
				To achieve this NUClear uses modern C++ features enabling us to perform partial message routing at compile time.
				Normally when you send a message there is a message broker executes some code to find the systems that are interested in a particular message.
				This system usually uses a number of intermediate steps to locate the appropriate messages.
				
				Additionally we are able to perform compile time memory allocation using template meta-programming to determine at compile time how much space is needed for messages.
				We can then use that information to preallocate the space before the program runs giving us the ability to send an arbitrary number of messages in O(1) time.
			
				Thanks to the mechanism used to allocate messages optimising compilers are also able to reason about the memory allocation of the messages at compile time which gives the compiler the opportunity to apply a number of powerful optimisations to how messages are sent.
				
				Our tests show that NUClear is able to operate between 1000-7000 times faster then competing message passing systems such as CORBA or RobotOS.
				
			\subsubsection{Smart Timers}
				In real-time systems it's common to have a number of systems that need to execute periodically. 
				In our analysis of the existing NUbots architecture we found several examples of systems that need to do something periodically.
				For example Camera frames need to be read every 50 milliseconds and Motors need to be updated every 30 milliseconds. 
				
				The way this is accomplished in the existing NUbots architecture is to manually set up a thread and have it block until the polling period is up. 
				Unfortunately this approach ties up a CPU thread doing almost nothing and wastes valuable hardware resources.
				
				NUClear provides an alternative mechanism that allows you to execute code periodically without tying up a CPU core.
				You can set up a reaction on a time event and NUClear will ensure that your reaction is called periodically. 
				Instead of busy waiting the system will run other tasks while the period task is waiting which ensures that CPU cycles are not wasted doing nothing.	
				
			\subsubsection{Statistics, Logging and Traceability}
				In complex system it can become very difficult to determine what the system is actually doing and why it's doing it. 
				The NUbots team made it clear that the ability to get per-module statistics and logs would be invaluable in tackling the challenges of robotic software development.
				
				To facilitate this NUClear is built with powerful statistics and logging tools. NUClear stores runtime statistics about each modules and provides mechanisms to get the information logs on a per-module or per-reaction basis. 
				By integrating these features into the NUbots architecture we are able to provide a large amount of useful information to assist them with debugging or understanding the robot system. 
				
				Additionally if an error occurs it's possible to capture the input that caused the error and replay it on the module. 
				This functionality can be used to develop a powerful array of tests that accurately simulate real-time scenarios.
				
				For example: If the robot kicks the ball and you expected it to do something else you can capture the inputs that made it decide to kick and replace them at your convenience. 
				It's also possible to encode the captured input into a unit test which can be automatically replayed. 
				This lets the NUbots team verify that the bug has been fixed and ensure that future changes don't cause a regression.
		
		\subsection{Architecture}
			NUClears architecture consists of three major building blocks: the \textbf{PowerPlant}, textbf{Reactor}s and \textbf{Reaction}s. 
		
		\subsection{Component Overview - Power Plant}
			The PowerPlant is the central message system through which all modules communicate. 
			Message routing is actually performed at compile time but from an API point of view the system still communicates through the PowerPlant.
			
			The PowerPlant has three main responsibilities which are split up into named subsystems called \emph{Masters}.
			
			In general when a message is emitted it is first cached by the CacheMaster. 
			The ThreadMaster then spawns a new thread and then tells the ReactorMaster to execute any reactions that are subscribed to that particular message. 
			The ReactorMaster then uses the CacheMaster to retrieve the message data and then invokes the reactions with the message data.
	
			\subsection{CacheMaster}
				The CacheMaster is responsible for ensuring that there is enough storage for all uses of a particular message.
				In most cases this means it needs to ensure there is space allocated for at least one instance of every message.
				However some extensions may require that more then the most recent message be cached and the CacheMaster also needs to account for that.
				
				The CacheMaster is fed the minimum allowable size for a particular message buffer at compile time by the PowerPlant.
				Internally the CacheMaster uses a data structure known as the TypeMap which is a compile-time mapping between types and instances of that type.
				By using this structure we are able to perform all cache sizing calculations at compile time and ensure that all messages are accounted for.
				
				Additionally the CacheMaster is the primary memory management facility for all messages in the system.
				The CacheMaster keeps track of references to messages and automatically cleans up memory when it is not longer used.
				It's possible for other systems to take ownership of data from the CacheMaster but it must be explicitly requested and is rare to see in regular modules.
				
				Routing of messages is technically a responsibility of the CacheMaster.
				However, we don't actually send messages for in-process communication in NUClear. 
				Instead messages are stored in the CacheMaster which then provides references to the ReactorMaster that are sent to the reactions.
				For the user this still looks like message routing but behind the scenes this approach gives us massive speed advantages of conventional copy-based routing.

			\subsection{ThreadMaster}				
				The ThreadMaster is responsible for multi-threading and task scheduling.
				It contains an internal thread pool that contains a number of workers. 
				Each worker executes a reaction using the ReactorMaster and then requests a new task from a blocking queue.
				
				\todo[inline]{Extend section, more about the design/implementation details of this component}
	
			\subsection{ReactorMaster}
				The ReactorMaster handles the logic relating to \emph{On} and \emph{Emit} directly. 
				It can be thought of as the glue that holds Reactors, the ThreadMaster and the CacheMaster together.
				
				When a Reactor calls Emit behind the scenes it is actually calling on the ReactorMaster to resolve the request.
				The ReactorMaster uses the CacheMaster to cache the data that was emitted.
				The ReactorMaster then loops through all reactions in the reaction list for that message type and adds a task to the ThreadMaster for each reaction.
				
				Additionally the ReactorMaster can also execute reactions directly in the main thread. 
				This is useful for tasks that are faster then the overhead of moving data to a new thread and is sometimes used for very quick reactions.
			
				Interally all reactions are stored in a data structure similar to the TypeMap called a TypeList. 
				A TypeList is a compile-time list of instances of a particular type. This list can be iterated over extremely quickly and allows us to perform subscriber lookup in O(1) time.
				Combining this with the already fast CacheMaster is what gives us a lot of our speed advantage of RobotOS or DDX.
		
		\subsection{Component Overview - Reactor and Reaction}
			A Reactor encapsulates a single module that can send and receive messages.
			Each Reactor contains a number of Reactions which are a single function that is run in response to new data. 
			Reactions take immutable references to messages as arguments which provide a strong multithreading guarantee that allows multiple reactions accessing the same data to be run simultaneously.
			
			Reactors are the primary entry point to the NUClear API. 
			It is expected that each module in a system will extend from NUClear::Reactor and use it's member functions to send and receive messages.
			By subclassing from Reactor you gain access to the two main NUClear API functions \emph{On} and \emph{Emit}. 
			Additionally you also gain access to \emph{Log} which provides per-reactor logging capabilities.
	
			\subsubsection{On}
				\emph{On} subscribes a reaction to particular message. 
				On also has a number of arguments that customise what data it receives and triggers on.
				
				\begin{cppcode}
				\todo[inline]{Write up a code example}
				\end{cppcode}
				
			\subsubsection{Emit}
				\emph{Emit} sends data to the PowerPlant which routes it to the subscribed reactions.
				Emit also has the concept of scopes which allows you to send data in different ways or to different places (such as over the network).
				
				\begin{cppcode}
				\todo[inline]{Write up a code example}
				\end{cppcode}
	
			\subsubsection{Log}
				\emph{Log} provides a mechanism to log information against a particular reaction. 
				This provides logging information that is per-reaction rather then system-wide giving greater traceability.
				
				\begin{cppcode}
				\todo[inline]{Write up a code example}
				\end{cppcode}
				
		\subsection{Extension}
			\todo[inline] {Write about how the system can be extended through partial speicalization of TriggerType, Exists, Get, and Emit}
			
		\subsection{Smart Types}
			\todo[inline]{Write an introduction to the concepts of smart types (as part of extension)}
			
			\subsubsection{Every}
				\todo[inline] {Move the section about smart timers here + stuff from training presentation}
				\todo[inline] {code example and explanation}
				
			\subsubsection{Last}
				\todo[inline] {Stuff from training presetnation}
				\todo[inline] {code example and explanation}
			
			\todo[inline] {Transfer the sections from the training presettaion over here with points expanded}
	
		\subsection{Component Overview - Networking}
			\todo[inline] {Talk about Networking as an Extension here}
			
			\begin{cppcode}
			\todo[inline]{Write up a code example}
			\end{cppcode}
			
			\missingfigure{Diagram of network communication between robots}
			
	\section{NUClear Powered NUbots}
		\todo[inline]{Write introduction to the concept of nuclear in nubots}
		
		\subsection{Architecture}
			\todo[inline]{Description and diagram of architecture, possibly steal/enhance diagram in test document}
			
		\subsection{Orchistration/Roles}
			\todo[inline]{Describe the process of orcistration and its implications}
		
		\subsection{Modules}
			\todo[inline]{Build up a template for a module and get information from readme.md files}
			\todo[inline]{If time allows write up a small description and design of each module, much of this content should be available from the Readme.md files}
			\subsubsection{AubioBeatDetector}
			\subsubsection{AudioFileInput}
			\subsubsection{AudioInput}
			\subsubsection{BeatDetector}
			\subsubsection{ConfigSystem}
			\subsubsection{DarwinHardwareIO}
			\subsubsection{DanceEngine}
			\subsubsection{DarwinMotionManager}
			\subsubsection{eSpeak}
			\subsubsection{NUbugger}
			\subsubsection{LinuxCameraStreamer}
			\subsubsection{PartyDarwin}
			\subsubsection{ScriptEngine}
			\subsubsection{ScriptRunner}
			\subsubsection{ScriptTuner}
				\todo[inline]{Possible screenshot for this one since it is a GUI application}


	\todo[inline]{Either have some references or remove this section}
	\bibliographystyle{plain}
	\bibliography{references}
	
	\printglossaries
\end{document}
