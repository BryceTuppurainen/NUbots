% Initialisation
\documentclass[english,12pt]{scrartcl}

\usepackage[]{babel}
% Input is utf8
\usepackage[utf8]{inputenc}
% Enables headers and footers
\usepackage[]{scrpage2}
% Lets us colour table cells
\usepackage[table]{xcolor}
% Allows todo list and todos
\usepackage[]{todonotes}
% Makes links in contents hyperlinked
\usepackage{hyperref}
% Make references appear in our table of contents
\usepackage[nottoc,numbib]{tocbibind}
% Allows us to put landscape sections of the document
\usepackage{pdflscape} % \usepackage{lscape} %Use escape for printing (doesn't rotate the pdf page)
% Provides a glossary
\usepackage[toc]{glossaries}

\usepackage{tabularx} % For tables
\usepackage[a4paper]{geometry} %specifies page width
\newgeometry{bottom=2cm, top=2cm}
\renewcommand{\arraystretch}{1.5}

\newcounter{testcounter}

\newcommand{\test}[1] {
	\stepcounter{testcounter}
	\item[] Test \arabic{testcounter}: \emph{#1}.}

\title{Project Proposal - Revision}
\author{Trent Houliston \and Jake Woods}

% Header and Footer
\pagestyle{scrheadings}
\ihead{\today}
\chead{}
\ohead{Project Proposal - Revision}
\ifoot{}
\cfoot{}
\ofoot{\pagemark}

% Skip line rather then indent paragraphs
\setlength{\parindent}{0.0in}
\setlength{\parskip}{0.1in}

\begin{document}
	\maketitle
	\vfill
	{\large
		\begin{description}
			\item [Status:] Release 1
			\item [Version:] 1.0
		\end{description}}

	\clearpage
	\tableofcontents
	\clearpage

\section{Introduction}
	This document outlines the scope of testing applied to the implementation of the new architecture for the RoboCup codebase. 
	The original architecture relied on purely manual processes for all testing.
	 
	We believe that the new architecture should utilise automated testing whenever feasible while using manual testing as a last-resort backup.
	
	In the new architecture functionality is separate into discrete modules that communicate through messages. 
	Accordingly we can separate our unit tests into per-module tests providing clean separation of concerns and simple mechanisms for mocking and validating inputs/outputs.
	We have also identified a number of cases where integration tests can be performed on module subsets further reducing the complexity of testing the system.
	End-to-end testing will still require manual validation as fully automated end-to-end testing would require an emulation layer for the robots hardware that was outside the scope of this project.

\section{Scope}
	The newly ported system has been split into many mutually exclusive sub modules and many are able to be tested in isolation using unit tests.
	Some of the modules however	must be manually tested due to their reliance on hardware in the system.
	An outline of the modules which have been ported and built on the new system as well as the testing method required is outlined below.
	\begin{tabular}{|p{7cm}|p{7cm}|}
		\hline \textbf{\large Module} & \textbf{\large Testing Method} \\ \hline
		AubioBeatDetector     & Automated Testing  \\ \hline
		AudioFileInput        & Automated Testing  \\ \hline
		AudioInput            & Manual Testing     \\ \hline
		BeatDetector          & Automated Testing  \\ \hline
		ConfigSystem          & Automated Testing  \\ \hline
		DarwinHardwareIO      & Manual Testing     \\ \hline
		DarwinMotionManager   & Automated Testing  \\ \hline
		eSpeak                & Manual Testing     \\ \hline
		NUbugger              & Manual Testing     \\ \hline
		LinuxCameraStreamer   & Manual Testing     \\ \hline
		PartyDarwin           & Unit Testable      \\ \hline
		ScriptEngine          & Automated Testing  \\ \hline
		ScriptRunner          & Automated Testing  \\ \hline
	\end{tabular}
	
\section{Modules}
	\subsection{AubioBeatDetector \& BeatDetector}
		AubioBeatDetector detects beats in a supplied audio stream using the Aubio library.
		BeatDetector detects beats using the Beat'n algorithm.
		As both of these modules have identical input and output, the testing method for these two modules is also identical.
		Beats are reported as the time the beat occurred and the tempo.
		These two modules are able to be tested through automated unit testing.
		
		\paragraph{Requirements:}
		\begin{itemize}
			\item This module is required to be able to accept a stream of audio chunks in PCM format and locate beats within it.
			\item The beats when found should be immediately emitted containing both the absolute time the beat occurred, and the estimated frequency of the beats.
			\item The beat detector must maintain above 90\% accuracy when provided with a audio file with a significant beat.
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item It is assumed that prior to any sound data being received, that the system will have received configuration information describing the sample rate, chunk size, and data frequency that will be used.
			\item It is also assumed that the sound information send has a distinguishable beat, failing this the output is undefined.
		\end{itemize}
		
		\begin{tabular}{p{7cm}|p{7cm}}
    			\textbf{Input Data} & \textbf{Output Data} \\ \hline
			\begin{itemize}
				\item An Audio configuration file describing the format of the incoming data.
				\item A series of sound chunks carrying raw PCM data
			\end{itemize}
			&
			\begin{itemize}
				\item The time and tempo of each beat as it happens.
			\end{itemize}
		\end{tabular}
		
		\paragraph{Tests:}
		\begin{itemize}
			\test{Test that the beat detector is able to detect beats in an audio stream}
			\begin{itemize}
				\item Load PCM data that contains a distinguishable beat
				\item Pre-identify and mark the location of beats in the data
				\item Output the format that this PCM data is in (Sample rate, Chunk size)
				\item Output the PCM data in chunks which match the previously outputted settings
				\item Monitor the emissions of Beat objects, and check that they match the previously identified beats (to within a tolerance)
			\end{itemize}
			
			\test{Test that the beat detector is able to handle different sample rates and chunk sizes}
			\begin{itemize}
				\item Load two separate PCM datasets with different sample rates
				\item Output the format that the first of these datasets is in
				\item Ensure that the beat detector works as expected
				\item Output the format that the second of these datasets is in
				\item Ensure that the beat detector continues to work as expected
			\end{itemize}
		\end{itemize}

	\subsection{AudioFileInput}
		AudioFileInput reads from a wav file specified in its configuration. 
		It the emits SoundChunk messages periodically as if it was listening to the file through a physical input device.
		
		\paragraph{Requirements:}
		\begin{itemize}
			\item This module must be able to load files in the WAV format
			\item This module must be able to load files of varying file formats
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item Files will only be provided in WAV format
			\item Files that are specified exist and are readable
		\end{itemize}
		
		\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
			\begin{itemize}
				\item A Configuration object providing the location of a wav file to be read.
			\end{itemize}
			&
			\begin{itemize}
				\item A single AudioConfiguration object, describing the format of the loaded sound.
				\item The binary PCM data from the wav file, split into chunks.
			\end{itemize}
		\end{tabular}
		
		\paragraph{Tests:}
		\begin{itemize}
			\test{The module is able load a wave file and output its file format and PCM data}
			\begin{itemize}
				\item A file location to a WAV file is provided though a configuration message
				\item The file is opened and emits a message containing the files sample rate, as well as the calculated chunk size
				\item Ensure the system then output chunks in simulated real time (1 second per second)
				\item Ensure that these chunks match the PCM data contained in the WAV file
			\end{itemize}
		\end{itemize}
		
	\subsection{AudioInput}
		AudioInput reads from the default audio input device.
		It emits SoundChunk messages periodically as more data is read in from the input device.
		This module must be manually tested due to its dependence on hardware.
		
		\paragraph{Requirements:}
		\begin{itemize}
			\item This module must be able to read in live audio from a physical audio device
			\item The data that is generated must be emitted in PCM format
			\item This module must output configuration regarding its sample rate and chunk size before outputting PCM data
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item The system must have a physical audio input device to read from
			\item The physical hardware must be enabled and be in working order
		\end{itemize}
		
		\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
			\begin{itemize}
				\item None
			\end{itemize}
			&
			\begin{itemize}
				\item A single AudioConfiguration object, describing the format of the streamed sound.
				\item The binary PCM data as obtained from the microphone, split into chunks.
			\end{itemize}
		\end{tabular}

		\paragraph{Tests:}
		\begin{itemize}
			\test{The AudioInput module is able to read in sound data from the audio source}
			\begin{itemize}
				\item The module should access the default audio capture device automatically
				\item The module should output the maximum sample rate and channels available on this device
				\item The module should then output chunks of audio as they are received from the device
				\item This PCM data should be captured and played back
				\item The sound from playing back this audio should be checked for similarity to the ambient noise
			\end{itemize}
			\test{The AudioInput module correctly selects the audio device based on system settings}
			\begin{itemize}
				\item The module should access the audio device chosen as the default system capture device
				\item The default capture device should be changed to an alternative device
				\item The module should be restarted, and then access this new device
			\end{itemize}
		\end{itemize}

	\subsection{ConfigSystem}
		The ConfigSystem loads JSON-formatted key-value configuration files and supplies them to other modules.
		These modules can be loaded either by referencing an individual file, or by referencing an entire directory.
		ConfigSystem loads JSON-formatted configuration files and supplies them to other modules.
		The config system can be automatically tested through unit testing.
		
		\paragraph{Requirements:}
		\begin{itemize}
			\item The config system must be able to load individual JSON formatted files
			\item The config system must be able to load directories of JSON formatted files
			\item The config system must be able to monitor changes in these files and notify systems which use them
			\item The config system must be able to convert these JSON files into useable objects
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item Files are assumed in JSON format
			\item The requested directory is readable
			\item All configuration files are assumed to be within a single directory subtree
		\end{itemize}
		
		\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
			\begin{itemize}
				\item A requested configuration file or directory to monitor.
				\item A configuration and a file path to save the configuration into.
			\end{itemize}
			&
			\begin{itemize}
				\item The configuration contained within a configuration file limited to the scope of the requesting module.
				\item The configuration of each file in a directory in the case of a request for a directory.
				\item Any updates to the monitored configuration files as they files they came from are modified.
			\end{itemize}
		\end{tabular}

		\paragraph{Tests:}
		\begin{itemize}
			\test{The Config system is able to load from a JSON file}
			\begin{itemize}
				\item A pre generated JSON file for a configuration should be made
				\item A mock module should request this JSON file path
				\item The resulting data should be the same as the contents of the JSON file
			\end{itemize}
			
			\test{The Config system ensures that configurations only go to interested modules}
			\begin{itemize}
				\item Two pre generated JSON files should be created
				\item Two mock modules should be made
				\item Each of these modules should request alternate configuration files
				\item It should be ensured that the contents provided by the configuration system are for only the configuration requested
			\end{itemize}
			
			\test{The Config system is able to load directories containing configuration files}
			\begin{itemize}
				\item A directory should be filled with several JSON configuration files
				\item A mock module should be made to request this directory
				\item It should be ensured that the module receives each of the configurations in turn
			\end{itemize}
			
			\test{The Config system is able to respond to modifications on loaded files}
			\begin{itemize}
				\item A JSON configuration file, and directory containing several files should be created
				\item Two mock modules one checking the directory and one checking the file should be created
				\item Once the files have been loaded initially, the files should be modified
				\item It should be ensured that the modules that requested those configurations are notified of their modification
				\item It should also be tested that adding a new configuration to the directory results in an update to the module
			\end{itemize}
		\end{itemize}

	\subsection{DanceEngine}
		The dance engine is responsible for taking the incoming beat frequency of detected audio, and executing scripts on the robot that allow it to dance to the beat.
		This module can be automatically tested through unit testing
		
		\paragraph{Requirements:}
		\begin{itemize}
			\item The module must be able to scale dance scripts to fit beats
			\item The module must not make dance moves rotate a servo faster then it is capable
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item It is assumed that there exists at least one dance script to execute
			\item It is assumed that no dance scripts rotate a servo faster then it is capable
			\item It is assumed that the beat that is to be used is a regular pattern
		\end{itemize}
		
		\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
			\begin{itemize}
				\item A Dance configuration describing the available dance scripts.
				\item A stream of beat detections describing the time of detection and tempo.
				\item A notification when all motors have completed their assigned tasks.
			\end{itemize}
			&
			\begin{itemize}
				\item A dance script scaled to the detected beat.
			\end{itemize}
		\end{tabular}

		\paragraph{Tests:}
		\begin{itemize}
			\test{The dance engine scales scripts lengths to match the period of the beat}
			\begin{itemize}
				\item A dance script should be created
				\item A beat of a known period should be emitted
				\item It should be ensured that the total length of the dance script is a multiple of the beat period
			\end{itemize}
			
			\test{The dance engine ensures that dance scripts execute such that they begin and end on beats}
			\begin{itemize}
				\item A dance script should be created
				\item A beat of a known period should be emitted
				\item It should be ensured that the start time and end time of the dance script 
			\end{itemize}
			
			\test{The dance engine continously picks random dances}
			\begin{itemize}
				\item A selection of dance scripts should be created
				\item A beat of a known period should be emitted at the period of the beat
				\item The dance scripts which are emitted should be randomly selected from all available scripts
			\end{itemize}
		\end{itemize}
		
	\subsection{eSpeak}
		The eSpeak module takes a string command and performs a text to speech conversion on it.
		This sound data is then outputted through the speaker of the system.
		Due to the reliance on hardware, this module must be manually tested.
		
		\paragraph{Requirements:}
		\begin{itemize}
			\item This module must be able to perform text to speech on strings of text
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item The text to be converted contains only alphanumeric text
			\item The text to be converted should be in English
			\item The system contains a sound device capable of outputting audio
		\end{itemize}
		
		\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
			\begin{itemize}
				\item A message containing the string to speak.
			\end{itemize}
			&
			\begin{itemize}
				\item None
			\end{itemize}
		\end{tabular}

		\paragraph{Tests:}
		\begin{itemize}
			\test{eSpeak performs text to speach when a Say command is emitted}
			\begin{itemize}
				\item A message containing a string of english text should be emitted
				\item The sound device should output the spoken text to speech version of the text
			\end{itemize}
		\end{itemize}
		
	\subsection{LinuxCameraStreamer}
		The LinuxCameraStreamer uses the V4L2 Linux Kernel API in order to read live data from the webcam of a computer.
		Due to the reliance on a webcam, this module must be manually tested.
		
		\paragraph{Requirements:}
		\begin{itemize}
			\item The module must be able to load images in real time from a webcam
			\item The module must be able to change the configuration of the camera
			\item The module must be able to handle multiple formats of camera streaming
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item The system has a webcam available to be accessed
			\item The systems webcam is supported by the Video for Linux 2 framework
		\end{itemize}

		\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
			\begin{itemize}
				\item A Camera configuration describing the camera settings.
			\end{itemize}
			&
			\begin{itemize}
				\item The raw video frames as they are recorded.
			\end{itemize}
		\end{tabular}

		\paragraph{Tests:}
		\begin{itemize}
			\test{The LinuxCameraStreamer is able to read an incoming video stream from the camera}
			\begin{itemize}
				\item Setup the module with camera settings compatible with the camera
				\item Ensure that the number of frames received per second is equal to the set FPS
				\item Ensure the images that are received are the images that would be collected by the camera
			\end{itemize}
			
			\test{The LinuxCameraStreamer will respond and update settings on the camera when needed}
			\begin{itemize}
				\item Configure the camera with settings compatible with the camera
				\item Ensure that it is emitting images as expected
				\item Update the configuration with options compatible with the camera
				\item Ensure that the camera has updated its settings and is emitting images with the new settings
			\end{itemize}
		\end{itemize}
		
	\subsection{NUbugger}
		NUbugger is a debugging system which integrates with a web browser.
		It is used to display useful debugging information from the robot while it is running.

		\paragraph{Requirements:}
		\begin{itemize}
			\item \todo[inline]{write}
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item \todo[inline]{write}
		\end{itemize}

		\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
			\begin{itemize}
				\item Realtime sensor information.
				\item Realtime image data.
			\end{itemize}
			&
			\begin{itemize}
				\item Networked packets containing sensor and image data.
			\end{itemize}
		\end{tabular}

		\paragraph{Tests:}
		\begin{itemize}
			\test{NUbugger sends out diagnostic data to the web server}
			\begin{itemize}
				\item \todo[inline]{write}
			\end{itemize}
		\end{itemize}
		
	\subsection{Platform Darwin HardwareIO}
		The Darwin Hardware IO module is responsible for directly interacting with the hardware on the robot.

		\paragraph{Requirements:}
		\begin{itemize}
			\item \todo[inline]{write}
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item \todo[inline]{write}
		\end{itemize}
		
		\begin{tabular}{p{7cm}|p{7cm}}
			Input Data & Output Data \\ \hline
			\begin{itemize}
				\item Servo motor commands describing a target point the motor needs to move to.
			\end{itemize}
			&
			\begin{itemize}
				\item Sensor information
			\end{itemize}
		\end{tabular}

		\paragraph{Tests}
		\begin{itemize}
			\test{The current data from the hardware is able to be read into SI units}
			\begin{itemize}
				\item \todo[inline]{write}
			\end{itemize}
			
			\test{Commands are able to be sent to the hardware and they are executed properly}
			\begin{itemize}
				\item \todo[inline]{write}
			\end{itemize}
			
			\test{The conversions performed in the Darwin HardwareIO are accurate}
			\begin{itemize}
				\item \todo[inline]{write}
			\end{itemize}
		\end{itemize}

	\subsection{Platform Darwin MotionManager}
		The MotionManager module is responsible for converting higher level motion commands into commands which can be executed on the robots hardware.
		
		\paragraph{Requirements:}
		\begin{itemize}
			\item \todo[inline]{write}
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item \todo[inline]{write}
		\end{itemize}
		
		\begin{tabular}{p{7cm}|p{7cm}}
			Input Data & Output Data \\ \hline
			\begin{itemize}
				\item A list of servo angle waypoints with the absolute time to be at these angles.
			\end{itemize}
			&
			\begin{itemize}
				\item A list of physical motor movements to enact the given waypoints.
			\end{itemize}
		\end{tabular}

		\paragraph{Tests:}
		\begin{itemize}
			\test{Waypoints sent to the motion manager are executed as hardware commands}
			\begin{itemize}
				\item \todo[inline]{write}
			\end{itemize}
			
			\test{If a new waypoint arrives MotionManager should drop all waypoints after the execution time of the new waypoint}
			\begin{itemize}
				\item \todo[inline]{write}
			\end{itemize}
			
			\test{MotionManager should correctly calculate the speed required to arrive at a particular waypoint in time}
			\begin{itemize}
				\item \todo[inline]{write}
			\end{itemize}
			
			\test{MotionManager should split waypoints if the angle traveled is larger then $2\pi$ radians}
			\begin{itemize}
				\item \todo[inline]{write}
			\end{itemize}
		\end{itemize}
			
	\subsection{ScriptEngine}
		The script engine of the system is responsible for taking Scripts (a series of waypoints) that are provided by the config system, and then executing them on demand via the MotionManager.
		
		\paragraph{Requirements:}
		\begin{itemize}
			\item \todo[inline]{write}
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item \todo[inline]{write}
		\end{itemize}
		
		\begin{tabular}{p{7cm}|p{7cm}}
			Input Data & Output Data \\ \hline
			\begin{itemize}
				\item A script configuration object describing the available scripts.
				\item A execute script command detailing the script to execute.
			\end{itemize}
			&
			\begin{itemize}
				\item A series of servo waypoint commands representing the script.
			\end{itemize}
		\end{tabular}

		\paragraph{Tests:}
		\begin{itemize}
			\test{The script engine can execute the scripts loaded into it}
			\begin{itemize}
				\item \todo[inline]{write}
			\end{itemize}
			
			\test{The script engine will respond to changes in the scripts if the file is modified}
			\begin{itemize}
				\item \todo[inline]{write}
			\end{itemize}
		\end{itemize}
		
	\subsection{ScriptRunner}
		The ScriptRunner is a user interface reactor which is used to execute a series of scripts via the script engine.
		
		\paragraph{Requirements:}
		\begin{itemize}
			\item \todo[inline]{write}
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item \todo[inline]{write}
		\end{itemize}
		
		\begin{tabular}{p{7cm}|p{7cm}}
			Input Data & Output Data \\ \hline
			\begin{itemize}
				\item Command Line Arguments representing the scripts to run.
			\end{itemize}
			&
			\begin{itemize}
				\item A sequential set of messages indicating the next script to execute.
			\end{itemize}
		\end{tabular}

		\paragraph{Tests:}
		\begin{itemize}
			\test{The script runner is able to execute consecutive scripts}
			\begin{itemize}
				\item \todo[inline]{write}
			\end{itemize}
		\end{itemize}
		
	\subsection{ScriptTuner}
		The ScriptTuner is a user interface which allows the user to generate and modify scripts to be executed on the robot.
		
		\paragraph{Requirements:}
		\begin{itemize}
			\item \todo[inline]{write}
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item \todo[inline]{write}
		\end{itemize}
		
		\begin{tabular}{p{7cm}|p{7cm}}
			Input Data & Output Data \\ \hline
			\begin{itemize}
				\item Nothing
			\end{itemize}
			&
			\begin{itemize}
				\item Motion Commands
			\end{itemize}
		\end{tabular}

		\paragraph{Tests:}
		\begin{itemize}
			\test{The script tuner is able to load existing script files}
			\begin{itemize}
				\item \todo[inline]{write}
			\end{itemize}
			
			\test{The script tuner is able to create new script files}
			\begin{itemize}
				\item \todo[inline]{write}
			\end{itemize}
			
			\test{The script tuner is able to save modified and new scripts}
			\begin{itemize}
				\item \todo[inline]{write}
			\end{itemize}
		\end{itemize}
		
\section{Integration Testing}
	\todo{if you take away the hardware specific modules it is possible to test the entire system}
	
\end{document}