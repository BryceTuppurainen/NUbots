\documentclass[a4paper]{article}
\usepackage{hyperref}          % Makes links in hyperlinked
\usepackage{url}               % Allows the use of URLs with links and formatting
\usepackage[parfill]{parskip}  % Makes paragraphs be on a new line with no indent
\usepackage{todonotes}         % Allows todo comments

\title{Test Plan}
\author{Jake Woods, Trent Houliston}
\date{\today}

\newcounter{testcounter}

\newcommand{\test}[2][pass] {
	\stepcounter{testcounter}
	Test \arabic{testcounter}: \emph{#2}. \textbf{\uppercase{#1}} \\}



\begin{document}

\maketitle

\section{Introduction}
	This document outlines the scope of testing applied to the implementation of the new architecture for the robocup codebase. 
	The original architecture relied on purely manual processes for all testing.
	 
	We believe that the new architecture should utilise automated testing whenever feasible while using manual testing as a last-resort backup.
	
	In the new architecture functionality is separate into discrete modules that communicate through messages. 
	Accordingly we can separate our unit tests into per-module tests providing clean separation of concerns and simple mechanisms for mocking and validating inputs/outputs.
	We have also identified a number of cases where integration tests can be performed on module subsets further reducing the complexity of testing the system.
	End-to-end testing will still require manual validation as fully automated end-to-end testing would require an emulation layer for the robots hardware that was outside the scope of this project.

\section{Scope}
	The following modules can be automatically unit tested:
	\begin{itemize}
		\item AubioBeatDetector
		\item BeatDetector
		\item ConfigSystem
		\item PartyDarwin
		\item ScriptEngine
		\item ScriptRunner
		\item Platform/Darwin/MotionManager
	\end{itemize}

	The following module combinations can be combined into automatic integration tests:
	\begin{itemize}
		\item AudioFileInput, (AubioBeatDetector or BeatDetector)
		\item ScriptRunner, Platform/Darwin/MotionManager
	\end{itemize}

	These modules require manual testing because they depend on robot hardware that we can't emulate:
	\begin{itemize}
		\item AudioInput
		\item eSpeak
		\item LinuxCameraStreamer
		\item NUBugger
		\item Platform/Darwin/HardwareIO
	\end{itemize}
	
	
\section{Modules}
	\subsection{AubioBeatDetector}
		\subsubsection{Description}
			AubioBeatDetector detects beats in a supplied audio stream using the Aubio library.
			Beats are reported as the time the beat occurred and the tempo.
						
			\begin{tabular}{p{5cm}|p{5cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item An Audio configuration file describing the format of the incoming data.
					\item A series of sound chunks carrying raw PCM data
				\end{itemize}
				&
				\begin{itemize}
					\item The time and tempo of each beat as it happens.
				\end{itemize}
    		\end{tabular}
			
		\subsubsection{Tests}
			\test{The beat detector is able to detect beats in an audio source}
			\test{The beat detector should not crash on empty audio streams}
			\test{The beat detector configuration should update automatically when parameters are changed}

	\subsection{AudioFileInput}
		\subsubsection{Description}
			AudioFileInput reads from a wav file specified in its configuration. 
			It the emits SoundChunk messages periodically as if it was listening to the file through the input device.
			
			\begin{tabular}{p{5cm}|p{5cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item A Configuration object providing the location of a wav file to be read.
				\end{itemize}
				&
				\begin{itemize}
					\item A single AudioConfiguration object, describing the format of the loaded sound.
					\item The binary PCM data from the wav file, split into chunks.
				\end{itemize}
    		\end{tabular}
			
		\subsubsection{Tests}
			\test{The module is able load a wave file and output its PCM data}
			\test{The module correctly outputs configuration data from the wave file}
			\test{The module correctly selects the file to load from its configuration}

	\subsection{AudioInput}
		\subsubsection{Description}
			AudioInput reads from the default audio input device.
			It emits SoundChunk messages periodically as more data is read in from the input device.
						
			\begin{tabular}{p{5cm}|p{5cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item None
				\end{itemize}
				&
				\begin{itemize}
					\item A single AudioConfiguration object, describing the format of the streamed sound.
					\item The binary PCM data as obtained from the microphone, split into chunks.
				\end{itemize}
    		\end{tabular}

		\subsubsection{Tests}
			\test{The AudioInput module is able to read in sound data from the audio source}
			\test{The AudioInput module correctly outputs the configuration of the audio source}
			\test{The AudioInput module correctly selects the audio device based on system settings}
			
	\subsection{BeatDetector}
		\subsubsection{Description}
			BeatDetector detects beats in a supplied audio stream using the a custom algorithm Beat'n.
			Beats are reported as the time the beat occurred and the tempo.
						
			\begin{tabular}{p{5cm}|p{5cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item An Audio configuration file describing the format of the incoming data.
					\item A series of sound chunks carrying raw PCM data
				\end{itemize}
				&
				\begin{itemize}
					\item The time and tempo of each beat as it happens.
				\end{itemize}
    		\end{tabular}

		\subsubsection{Tests}
			\test{The beat detector is able to detect beats in an audio source}
			\test{The beat detector should not crash on empty audio streams}
			\test{The beat detector configuration should update automatically when parameters are changed}

	\subsection{ConfigSystem}
		\subsubsection{Description}
			The ConfigSystem loads JSON-formatted key-value configuration files and supplies them to other modules.
			These modules can be loaded either by referencing an individual file, or by referencing an entire directory.
			ConfigSystem loads JSON-formatted configuration files and supplies them to other modules.
			
			\begin{tabular}{p{5cm}|p{5cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item A requested configuration file or directory to monitor.
					\item A configuration and a file path to save the configuration into.
				\end{itemize}
				&
				\begin{itemize}
					\item The configuration contained within a configuration file limited to the scope of the requesting module.
					\item The configuration of each file in a directory in the case of a request for a directory.
					\item Any updates to the monitored configuration files as they files they came from are modified.
				\end{itemize}
    		\end{tabular}

		\subsubsection{Tests}
			\test{The Config system is able to load from a JSON file}
			\test{The Config system ensures that configurations only go to interested modules}
			\test{The Config system is able to load directories containing configuration files}
			\test{The Config system is able to respond to modifications on loaded files}

	\subsection{DanceEngine}
		\subsubsection{Description}
			The dance engine is responsible for taking the incoming beat frequency of detected audio, and executing scripts on the robot that allow it to dance to the beat.
			
			\begin{tabular}{p{5cm}|p{5cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item A Dance configuration describing the available dance scripts.
					\item A stream of beat detections describing the time of detection and tempo.
					\item A notification when all motors have completed their assigned tasks.
				\end{itemize}
				&
				\begin{itemize}
					\item A dance script scaled to the detected beat.
				\end{itemize}
    		\end{tabular}

		\subsubsection{Tests}
			\test{The dance engine scales scripts lengths to match the period of the beat}
			\test{The dance engine ensures that dance scripts execute such that they begin and end on beats}
			\test{The dance engine continously picks random dances}
		
	\subsection{eSpeak}
		\subsubsection{Description}
			The eSpeak module takes a string command and performs a text to speech conversion on it.
			This sound data is then outputted through the speaker of the system.
			
			\begin{tabular}{p{5cm}|p{5cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item A message containing the string to speak.
				\end{itemize}
				&
				\begin{itemize}
					\item None
				\end{itemize}
    		\end{tabular}

		\subsubsection{Tests}
			\test{eSpeak performs text to speach when a Say command is emitted}
		
	\subsection{LinuxCameraStreamer}
		\subsubsection{Description}
			The LinuxCameraStreamer uses the V4L2 Linux Kernel API in order to read live data from the webcam of a computer.
			
			\begin{tabular}{p{5cm}|p{5cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item A Camera configuration describing the camera settings.
				\end{itemize}
				&
				\begin{itemize}
					\item The raw video frames as they are recorded.
				\end{itemize}
    		\end{tabular}

		\subsubsection{Tests}
			\test{The LinuxCameraStreamer is able to read an incoming video stream from the camera}
			\test{The LinuxCameraStreamer will respond and update settings on the camera when needed}
			\test{The LinuxCameraStreamer accurately retrieves hardware settings}
		
	\subsection{NUBugger}
		\subsubsection{Description}
			NUBugger is a debugging system which integrates with a web browser.
			It is used to display useful debugging information from the robot while it is running.

			\begin{tabular}{p{5cm}|p{5cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item Realtime sensor information.
					\item Realtime image data.
				\end{itemize}
				&
				\begin{itemize}
					\item Networked packets containing sensor and image data.
				\end{itemize}
    		\end{tabular}

		\subsubsection{Tests}
			\test{NUBugger sends out diagnostic data to the web server}
		
	\subsection{Platform Darwin HardwareIO}
		\subsubsection{Description}
			The Darwin Hardware IO module is responsible for directly interacting with the hardware on the robot.
			
			\begin{tabular}{p{5cm}|p{5cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item Servo motor commands describing a target point the motor needs to move to.
				\end{itemize}
				&
				\begin{itemize}
					\item Sensor information
				\end{itemize}
    		\end{tabular}

		\subsubsection{Tests}
			\test{The current data from the hardware is able to be read into SI units}
			\test{Commands are able to be sent to the hardware and they are executed properly}
			\test{The conversions performed in the Darwin HardwareIO are accurate}

	\subsection{Platform Darwin MotionManager}
		\subsubsection{Description}
			The MotionManager module is responsible for converting higher level motion commands into commands which can be executed on the robots hardware.
			
			\begin{tabular}{p{5cm}|p{5cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item A list of servo angle waypoints with the absolute time to be at these angles.
				\end{itemize}
				&
				\begin{itemize}
					\item A list of physical motor movements to enact the given waypoints.
				\end{itemize}
    		\end{tabular}

		\subsubsection{Tests}
			\test{Waypoints sent to the motion manager are executed as hardware commands}
			\test{If a new waypoint arrives MotionManager should drop all waypoints after the execution time of the new waypoint}
			\test{MotionManager should correctly calculate the speed required to arrive at a particular waypoint in time}
			\test{MotionManager should split waypoints if the angle traveled is larger then $2\pi$ radians}
			
	\subsection{ScriptEngine}
		\subsubsection{Description}
			The script engine of the system is responsible for taking Scripts (a series of waypoints) that are provided by the config system, and then executing them on demand via the MotionManager.
			
			\begin{tabular}{p{5cm}|p{5cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item A script configuration object describing the available scripts.
					\item A execute script command detailing the script to execute.
				\end{itemize}
				&
				\begin{itemize}
					\item A series of servo waypoint commands representing the script.
				\end{itemize}
    		\end{tabular}

		\subsubsection{Tests}
			\test{The script engine can execute the scripts loaded into it}
			\test{The script engine will respond to changes in the scripts if the file is modified}
		
	\subsection{ScriptRunner}
		\subsubsection{Description}
			The ScriptRunner is a user interface reactor which is used to execute a series of scripts via the script engine.
			
			\begin{tabular}{p{5cm}|p{5cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item Command Line Arguments representing the scripts to run.
				\end{itemize}
				&
				\begin{itemize}
					\item A sequential set of messages indicating the next script to execute.
				\end{itemize}
    		\end{tabular}

		\subsubsection{Tests}
			\test{The script runner is able to execute consecutive scripts}
		
	\subsection{ScriptTuner}
		\subsubsection{Description}
			The ScriptTuner is a user interface which allows the user to generate and modify scripts to be executed on the robot.
			
			\begin{tabular}{p{5cm}|p{5cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item Nothing
				\end{itemize}
				&
				\begin{itemize}
					\item Motion Commands
				\end{itemize}
    		\end{tabular}

		\subsubsection{Tests}
			\test{The script tuner is able to load existing script files}		
			\test{The script tuner is able to create new script files}
			\test{The script tuner is able to save modified and new scripts}
					
\section{Test Results}
	\todo[inline]{Write Introduction}
		
\end{document}