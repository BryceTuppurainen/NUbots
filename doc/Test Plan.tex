% Initialisation
\documentclass[english,12pt]{scrartcl}

\usepackage[]{babel}
% Input is utf8
\usepackage[utf8]{inputenc}
% Enables headers and footers
\usepackage[]{scrpage2}
% Lets us colour table cells
\usepackage[table]{xcolor}
% Allows todo list and todos
\usepackage[]{todonotes}
% Makes links in contents hyperlinked
\usepackage{hyperref}
% Make references appear in our table of contents
\usepackage[nottoc,numbib]{tocbibind}
% Allows us to put landscape sections of the document
\usepackage{pdflscape} % \usepackage{lscape} %Use escape for printing (doesn't rotate the pdf page)
% Provides a glossary
\usepackage[toc]{glossaries}

\usepackage{tabularx} % For tables
\usepackage[a4paper]{geometry} %specifies page width
\newgeometry{bottom=2cm, top=2cm}
\renewcommand{\arraystretch}{1.5}

\newcounter{testcounter}

\newcommand{\test}[1] {
	\stepcounter{testcounter}
	\item[] Test \arabic{testcounter}: \emph{#1}.}

\title{Project Proposal - Revision}
\author{Trent Houliston \and Jake Woods}

% Header and Footer
\pagestyle{scrheadings}
\ihead{\today}
\chead{}
\ohead{Project Proposal - Revision}
\ifoot{}
\cfoot{}
\ofoot{\pagemark}

% Skip line rather then indent paragraphs
\setlength{\parindent}{0.0in}
\setlength{\parskip}{0.1in}

\begin{document}
	\maketitle
	\vfill
	{\large
		\begin{description}
			\item [Status:] Release 1
			\item [Version:] 1.0
		\end{description}}

	\clearpage
	\tableofcontents
	\clearpage

\section{Introduction}
	This document outlines the scope of testing applied to the implementation of the new architecture for the RoboCup codebase. 
	The original architecture relied on purely manual processes for all testing.
	 
	We believe that the new architecture should utilise automated testing whenever feasible while using manual testing as a last-resort backup.
	
	In the new architecture functionality is separate into discrete modules that communicate through messages. 
	Accordingly we can separate our unit tests into per-module tests providing clean separation of concerns and simple mechanisms for mocking and validating inputs/outputs.
	We have also identified a number of cases where integration tests can be performed on module subsets further reducing the complexity of testing the system.
	End-to-end testing will still require manual validation as fully automated end-to-end testing would require an emulation layer for the robots hardware that was outside the scope of this project.

\section{Scope}
	The newly ported system has been split into many mutually exclusive sub modules and many are able to be tested in isolation using unit tests.
	Some of the modules however	must be manually tested due to their reliance on hardware in the system.
	An outline of the modules which have been ported and built on the new system as well as the testing method required is outlined below.
	\begin{tabular}{|p{7cm}|p{7cm}|}
		\hline \textbf{\large Module} & \textbf{\large Testing Method} \\ \hline
		AubioBeatDetector     & Automated Testing  \\ \hline
		AudioFileInput        & Automated Testing  \\ \hline
		AudioInput            & Manual Testing     \\ \hline
		BeatDetector          & Automated Testing  \\ \hline
		ConfigSystem          & Automated Testing  \\ \hline
		DarwinHardwareIO      & Manual Testing     \\ \hline
		DarwinMotionManager   & Automated Testing  \\ \hline
		eSpeak                & Manual Testing     \\ \hline
		NUBugger              & Manual Testing     \\ \hline
		LinuxCameraStreamer   & Manual Testing     \\ \hline
		PartyDarwin           & Unit Testable      \\ \hline
		ScriptEngine          & Automated Testing  \\ \hline
		ScriptRunner          & Automated Testing  \\ \hline
	\end{tabular}
	
\section{Modules}
	\subsection{AubioBeatDetector \& BeatDetector}
		AubioBeatDetector detects beats in a supplied audio stream using the Aubio library.
		BeatDetector detects beats using the Beat'n algorithm.
		As both of these modules have identical input and output, the testing method for these two modules is also identical.
		Beats are reported as the time the beat occurred and the tempo.
		These two modules are able to be tested through automated unit testing.
		
		\paragraph{Requirements:}
		\begin{itemize}
			\item This module is required to be able to accept a stream of audio chunks in PCM format and locate beats within it.
			\item The beats when found should be immediately emitted containing both the absolute time the beat occurred, and the estimated frequency of the beats.
			\item The beat detector must maintain above 90\% accuracy when provided with a audio file with a significant beat.
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item It is assumed that prior to any sound data being received, that the system will have received configuration information describing the sample rate, chunk size, and data frequency that will be used.
			\item It is also assumed that the sound information send has a distinguishable beat, failing this the output is undefined.
		\end{itemize}
		
		\begin{tabular}{p{7cm}|p{7cm}}
    			\textbf{Input Data} & \textbf{Output Data} \\ \hline
			\begin{itemize}
				\item An Audio configuration file describing the format of the incoming data.
				\item A series of sound chunks carrying raw PCM data
			\end{itemize}
			&
			\begin{itemize}
				\item The time and tempo of each beat as it happens.
			\end{itemize}
		\end{tabular}
		
		\paragraph{Tests:}
		\begin{itemize}
			\test{Test that the beat detector is able to detect beats in an audio stream}
			\begin{itemize}
				\item Load PCM data that contains a distinguishable beat
				\item Pre-identify and mark the location of beats in the data
				\item Output the format that this PCM data is in (Sample rate, Chunk size)
				\item Output the PCM data in chunks which match the previously outputted settings
				\item Monitor the emissions of Beat objects, and check that they match the previously identified beats (to within a tolerance)
			\end{itemize}
			
			\test{Test that the beat detector is able to handle different sample rates and chunk sizes}
			\begin{itemize}
				\item Load two separate PCM datasets with different sample rates
				\item Output the format that the first of these datasets is in
				\item Ensure that the beat detector works as expected
				\item Output the format that the second of these datasets is in
				\item Ensure that the beat detector continues to work as expected
			\end{itemize}
		\end{itemize}

	\subsection{AudioFileInput}
		AudioFileInput reads from a wav file specified in its configuration. 
		It the emits SoundChunk messages periodically as if it was listening to the file through a physical input device.
		
		\paragraph{Requirements:}
		\begin{itemize}
			\item This module must be able to load files in the WAV format
			\item This module must be able to load files of varying file formats
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item Files will only be provided in WAV format
			\item Files that are specified exist and are readable
		\end{itemize}
		
		\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
			\begin{itemize}
				\item A Configuration object providing the location of a wav file to be read.
			\end{itemize}
			&
			\begin{itemize}
				\item A single AudioConfiguration object, describing the format of the loaded sound.
				\item The binary PCM data from the wav file, split into chunks.
			\end{itemize}
		\end{tabular}
		
		\paragraph{Tests:}
		\begin{itemize}
			\test{The module is able load a wave file and output its file format and PCM data}
			\begin{itemize}
				\item A file location to a WAV file is provided though a configuration message
				\item The file is opened and emits a message containing the files sample rate, as well as the calculated chunk size
				\item Ensure the system then output chunks in simulated real time (1 second per second)
				\item Ensure that these chunks match the PCM data contained in the WAV file
			\end{itemize}
		\end{itemize}
		
	\subsection{AudioInput}
		AudioInput reads from the default audio input device.
		It emits SoundChunk messages periodically as more data is read in from the input device.
		This module must be manually tested due to its dependence on hardware.
		
		\paragraph{Requirements:}
		\begin{itemize}
			\item This module must be able to read in live audio from a physical audio device
			\item The data that is generated must be emitted in PCM format
			\item This module must output configuration regarding its sample rate and chunk size before outputting PCM data
		\end{itemize}
		
		\paragraph{Assumptions:}
		\begin{itemize}
			\item The system must have a physical audio input device to read from
			\item The physical hardware must be enabled and be in working order
		\end{itemize}
		
		\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
			\begin{itemize}
				\item None
			\end{itemize}
			&
			\begin{itemize}
				\item A single AudioConfiguration object, describing the format of the streamed sound.
				\item The binary PCM data as obtained from the microphone, split into chunks.
			\end{itemize}
		\end{tabular}

		\paragraph{Tests:}
		\begin{itemize}
			\test{The AudioInput module is able to read in sound data from the audio source}
			\begin{itemize}
				\item The module should access the default audio capture device automatically
				\item The module should output the maximum sample rate and channels available on this device
				\item The module should then output chunks of audio as they are received from the device
				\item This PCM data should be captured and played back
				\item The sound from playing back this audio should be checked for similarity to the ambient noise
			\end{itemize}
			\test{The AudioInput module correctly selects the audio device based on system settings}
			\begin{itemize}
				\item The module should access the audio device chosen as the default system capture device
				\item The default capture device should be changed to an alternative device
				\item The module should be restarted, and then access this new device
			\end{itemize}
		\end{itemize}

	\subsection{ConfigSystem}
		\textbf{\large Description} \\
			The ConfigSystem loads JSON-formatted key-value configuration files and supplies them to other modules.
			These modules can be loaded either by referencing an individual file, or by referencing an entire directory.
			ConfigSystem loads JSON-formatted configuration files and supplies them to other modules.
			
			\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item A requested configuration file or directory to monitor.
					\item A configuration and a file path to save the configuration into.
				\end{itemize}
				&
				\begin{itemize}
					\item The configuration contained within a configuration file limited to the scope of the requesting module.
					\item The configuration of each file in a directory in the case of a request for a directory.
					\item Any updates to the monitored configuration files as they files they came from are modified.
				\end{itemize}
    		\end{tabular}

		\textbf{\large Tests} \\
			\test{The Config system is able to load from a JSON file}
			\test{The Config system ensures that configurations only go to interested modules}
			\test{The Config system is able to load directories containing configuration files}
			\test{The Config system is able to respond to modifications on loaded files}

	\subsection{DanceEngine}
		\textbf{\large Description} \\
			The dance engine is responsible for taking the incoming beat frequency of detected audio, and executing scripts on the robot that allow it to dance to the beat.
			
			\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item A Dance configuration describing the available dance scripts.
					\item A stream of beat detections describing the time of detection and tempo.
					\item A notification when all motors have completed their assigned tasks.
				\end{itemize}
				&
				\begin{itemize}
					\item A dance script scaled to the detected beat.
				\end{itemize}
    		\end{tabular}

		\textbf{\large Tests} \\
			\test{The dance engine scales scripts lengths to match the period of the beat}
			\test{The dance engine ensures that dance scripts execute such that they begin and end on beats}
			\test{The dance engine continously picks random dances}
		
	\subsection{eSpeak}
		\textbf{\large Description} \\
			The eSpeak module takes a string command and performs a text to speech conversion on it.
			This sound data is then outputted through the speaker of the system.
			
			\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item A message containing the string to speak.
				\end{itemize}
				&
				\begin{itemize}
					\item None
				\end{itemize}
    		\end{tabular}

		\textbf{\large Tests} \\
			\test{eSpeak performs text to speach when a Say command is emitted}
		
	\subsection{LinuxCameraStreamer}
		\textbf{\large Description} \\
			The LinuxCameraStreamer uses the V4L2 Linux Kernel API in order to read live data from the webcam of a computer.
			
			\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item A Camera configuration describing the camera settings.
				\end{itemize}
				&
				\begin{itemize}
					\item The raw video frames as they are recorded.
				\end{itemize}
    		\end{tabular}

		\textbf{\large Tests} \\
			\test{The LinuxCameraStreamer is able to read an incoming video stream from the camera}
			\test{The LinuxCameraStreamer will respond and update settings on the camera when needed}
			\test{The LinuxCameraStreamer accurately retrieves hardware settings}
		
	\subsection{NUBugger}
		\textbf{\large Description} \\
			NUBugger is a debugging system which integrates with a web browser.
			It is used to display useful debugging information from the robot while it is running.

			\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item Realtime sensor information.
					\item Realtime image data.
				\end{itemize}
				&
				\begin{itemize}
					\item Networked packets containing sensor and image data.
				\end{itemize}
    		\end{tabular}

		\textbf{\large Tests} \\
			\test{NUBugger sends out diagnostic data to the web server}
		
	\subsection{Platform Darwin HardwareIO}
		\textbf{\large Description} \\
			The Darwin Hardware IO module is responsible for directly interacting with the hardware on the robot.
			
			\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item Servo motor commands describing a target point the motor needs to move to.
				\end{itemize}
				&
				\begin{itemize}
					\item Sensor information
				\end{itemize}
    		\end{tabular}

		\textbf{\large Tests} \\
			\test{The current data from the hardware is able to be read into SI units}
			\test{Commands are able to be sent to the hardware and they are executed properly}
			\test{The conversions performed in the Darwin HardwareIO are accurate}

	\subsection{Platform Darwin MotionManager}
		\textbf{\large Description} \\
			The MotionManager module is responsible for converting higher level motion commands into commands which can be executed on the robots hardware.
			
			\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item A list of servo angle waypoints with the absolute time to be at these angles.
				\end{itemize}
				&
				\begin{itemize}
					\item A list of physical motor movements to enact the given waypoints.
				\end{itemize}
    		\end{tabular}

		\textbf{\large Tests} \\
			\test{Waypoints sent to the motion manager are executed as hardware commands}
			\test{If a new waypoint arrives MotionManager should drop all waypoints after the execution time of the new waypoint}
			\test{MotionManager should correctly calculate the speed required to arrive at a particular waypoint in time}
			\test{MotionManager should split waypoints if the angle traveled is larger then $2\pi$ radians}
			
	\subsection{ScriptEngine}
		\textbf{\large Description} \\
			The script engine of the system is responsible for taking Scripts (a series of waypoints) that are provided by the config system, and then executing them on demand via the MotionManager.
			
			\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item A script configuration object describing the available scripts.
					\item A execute script command detailing the script to execute.
				\end{itemize}
				&
				\begin{itemize}
					\item A series of servo waypoint commands representing the script.
				\end{itemize}
    		\end{tabular}

		\textbf{\large Tests} \\
			\test{The script engine can execute the scripts loaded into it}
			\test{The script engine will respond to changes in the scripts if the file is modified}
		
	\subsection{ScriptRunner}
		\textbf{\large Description} \\
			The ScriptRunner is a user interface reactor which is used to execute a series of scripts via the script engine.
			
			\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item Command Line Arguments representing the scripts to run.
				\end{itemize}
				&
				\begin{itemize}
					\item A sequential set of messages indicating the next script to execute.
				\end{itemize}
    		\end{tabular}

		\textbf{\large Tests} \\
			\test{The script runner is able to execute consecutive scripts}
		
	\subsection{ScriptTuner}
		\textbf{\large Description} \\
			The ScriptTuner is a user interface which allows the user to generate and modify scripts to be executed on the robot.
			
			\begin{tabular}{p{7cm}|p{7cm}}
    			Input Data & Output Data \\ \hline
				\begin{itemize}
					\item Nothing
				\end{itemize}
				&
				\begin{itemize}
					\item Motion Commands
				\end{itemize}
    		\end{tabular}

		\textbf{\large Tests} \\
			\test{The script tuner is able to load existing script files}		
			\test{The script tuner is able to create new script files}
			\test{The script tuner is able to save modified and new scripts}
\end{document}