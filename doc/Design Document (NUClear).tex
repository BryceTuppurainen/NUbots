% Initialisation
\documentclass[english,12pt]{scrartcl}
\usepackage[]{babel}
% Input is utf8
\usepackage[utf8]{inputenc}
% Enables headers and footers
\usepackage[]{scrpage2}
% Lets us colour table cells
\usepackage[table]{xcolor}
% Allows todo list and todos
\usepackage[]{todonotes}
% Makes links in contents hyperlinked
\usepackage{hyperref}
% Make references appear in our table of contents
\usepackage[nottoc,numbib]{tocbibind}
% Allows us to put landscape sections of the document
\usepackage{pdflscape} % \usepackage{lscape} %Use escape for printing (doesn't rotate the pdf page)
% Provides a glossary
\usepackage[toc]{glossaries}

% Gives us pretty diagrams
\usepackage{tikz}
\usetikzlibrary{calc,fit,positioning,chains,decorations.pathreplacing,shapes,backgrounds}

% Document Title and Author
\title{NUClear Design Document}
\author{2013 Final Year Project}

% Header and Footer
\pagestyle{scrheadings}
\ihead{\today}
\chead{}
\ohead{NUClear Design Document}
\ifoot{}
\cfoot{}
\ofoot{\pagemark}

% Requirements custom commands
\newcommand{\requirement}[1]{\textit{#1}}

% Skip line rather then indent paragraphs
\setlength{\parindent}{0.0in}
\setlength{\parskip}{0.1in}

% Start of document
\begin{document}
	\maketitle
	\vfill
	{\large
		\begin{description}
			\item [Status:] Draft 1
			\item [Version:] 0.1
		\end{description}}

	\clearpage
	\tableofcontents

	\section{Document Notes}
		\begin{tabular}{ p{0.1\textwidth} | p{0.6\textwidth} | p{0.3\textwidth} }
			\textbf{Version} & \textbf{Changes} & \textbf{Author} \\
			\hline

			0.1 &
			Initial Template &
			Jake Woods \\
			\hline

			0.2 &
			Fleshed Out Intro and Features
			Jake Woods \\
			\hline
		\end{tabular}
		
	\clearpage
		
	\section{Introduction}
		NUClear is a C++ library that enables developers to write modular systems that communicate using messages. 
		Modules are kept ignorant of each other and only know about the messages they send/receive. 
		This allows us to transparently drop in different producers/consumers without modifying the entire system.
		
		Originally NUClear was designed to replace a robot architecture that used a system known as the Blackboard.
		Blackboards are a shared global memory store that all modules use to communicate by writing data to the blackboard and assuming it is read by the next module.
		Our design makes it easy to transition from similar globally accessible data to a message based event-driven architecture.
		
		Our goal was to make a system that allows programmers to easily send/receive information between modules using mechanisms that are \textbf{Fast}, \textbf{Reliable} and \textbf{Intuitive}.

	\section{Goals}
		\subsection{Simple API}
			It was critical that NUClear have a simple and intuitive interface that didn't require weeks of study to achieve productivity with.
			With that in mind we ensured that the two key concepts, sending and receiving messages, only require the use of two corresponding functions: \textbf{On} and \textbf{Emit}
			
			NUClear is designed around these two functions. \textbf{On} provides mechanisms to indicate that you are interested in a particular piece of information.
			\textbf{Emit} correspondingly allows you to provide information to the system.
			
			There is a small amount of boilerplate requiring that you inherit from \textbf{NUClear::Reactor} and provide an appropriate constructor.
			However these are simply implementation details and do not require understanding to utilize the full power of the system.
		
		\subsection{Simple utilization of system resources}
			Another requirement derived from resource-constrained environments is the need to easily utilize the full power of the platform you run on.
			This is primarily achieve by introducing \textbf{Transparent Multi-threading} which automatically uses every physical core available on the system
			without the developer needing to fiddle with threading primitives.
			
			When a message is sent in the system the central coordination object known as the \textbf{PowerPlant} takes ownership of it. 
			From this point forward no modules can modify the message and only have read-only access to it.
			The PowerPlant then executes callbacks, known as reactions, that are subscribed to this message.
			Each reaction gets a immutable reference to the original message and can perform any read operations on it.
			
			Immutability is the key that allows us to transparently multi-thread the system.
			We know that multiple reactions will want to read the data and if we can guarantee that they don't modify it then we can
			run the reactions in parallel without worrying about race conditions.
			By forcing immutability we can move all threading logic directly into NUClear allowing developers to concentrate on their modules
			instead of threading problems.
			
			In most cases multi-threading will be completely transparent. 
			However it is still important that the developers understand that they are working in a multi-threaded environment.
			If a single module shares data between two reactions and those reactions could run in parallel then the shared data will
			need to be secured with a thread-safe mechanism such as a mutex.
			NUClear also provides functionality to let the user specify that certain reactions should not be run in parallel which can be used to solve threading concerns.
		
		\subsection{Low Performance Penalty}
			NUClear needs to run in resource-constrained environment where large API overhead is unacceptable.
			Because of this we have opted not to use technologies that incur large performance penalties such as XML serialization 
			instead opting for a direct binary representation for messages passed within a single process. 
			
			We use modern C++ features to perform \textbf{Compile-Time Allocation and Routing} which allows us to calculate and allocate space
			for all reactions and messages at compile time.
			Additionally we compute reaction lookup at compile-time to minimize the time it takes to emit or receive a message.
			In our tests these optimizations have allowed us to send an arbitrary number of messages in O(1) time.
			

			
		\subsection{Compile-Time Message Routing}
			NUClear leverages modern C++ features enabling us to perform partial message routing at compile time.
			Normally when you send a message there is a message broker executes some code to find the systems that are interested in a particular message.
			This system usually uses a number of intermediate steps to locate the appropriate messages.
			
			NUClear uses template meta-programming to determine at compile time how much space is needed for reactions and messages and allocates
			
			\todo[inline] {Write about feature}
			
		\subsection{Statistics and Logging}
			\todo[inline] {Write about stats and logging and how we solve the problem of multithreaded logging}
			
		\subsection{Extensible Architecture}
			\todo[inline] {Write about how we can do awesome extensions}
			
		\subsection{Smart Timers}
			\todo[inline] {Write about feature. No wasted CPU cycles using a wait-loop}

	\section{Component Overview - Power Plant}
		\todo[inline] {Expand this a lot}
		The PowerPlant has three main responsibilities which are split up into discreet classes.

		\subsection{ReactorMaster}
			\todo[inline] {Write about ReactorMaster}

		\subsection{ThreadMaster}
			\todo[inline] {Write about ThreadMaster}

		\subsection{CacheMaster}
			\todo[inline] {Write about CacheMaster}

	\section{Component Overview - Reactor}
		\todo[inline] {Write about Reactor and consider if On/Emit/Log are the appropriate subsections}

		\subsection{On}

		\subsection{Emit}

		\subsection{Log}

	\section{Component Overview - Reaction}
		\todo[inline] {Explain how the concept of a Reaction fits in here}

	\section{Component Overview - Networking}
		\todo[inline] {Talk about Networking as an Extension here}

	\bibliographystyle{plain}
	\bibliography{references}
	
	\printglossaries
\end{document}
